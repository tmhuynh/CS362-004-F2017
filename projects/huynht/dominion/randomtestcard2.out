Running Random Test for Mine
0 Tests Completed
1 Tests Completed
2 Tests Completed
3 Tests Completed
4 Tests Completed
5 Tests Completed
6 Tests Completed
7 test failed
7 Tests Completed
8 Tests Completed
9 Tests Completed
10 Tests Completed
11 Tests Completed
Test 12 cut short
12 Tests Completed
Test 13 cut short
13 Tests Completed
Test 14 cut short
14 Tests Completed
15 Tests Completed
Test 16 cut short
16 Tests Completed
17 Tests Completed
18 Tests Completed
19 Tests Completed
20 Tests Completed
21 Tests Completed
22 Tests Completed
Test 23 cut short
23 Tests Completed
Test 24 cut short
24 Tests Completed
Test 25 cut short
25 Tests Completed
Test 26 cut short
26 Tests Completed
Test 27 cut short
27 Tests Completed
Test 28 cut short
28 Tests Completed
29 Tests Completed
30 Tests Completed
Test 31 cut short
31 Tests Completed
32 Tests Completed
33 Tests Completed
Test 34 cut short
34 Tests Completed
Test 35 cut short
35 Tests Completed
Test 36 cut short
36 Tests Completed
Test 37 cut short
37 Tests Completed
Test 38 cut short
38 Tests Completed
39 Tests Completed
40 Tests Completed
41 Tests Completed
42 Tests Completed
43 Tests Completed
Test 44 cut short
44 Tests Completed
45 Tests Completed
46 Tests Completed
47 Tests Completed
48 test failed
48 Tests Completed
Test 49 cut short
49 Tests Completed
Test 50 cut short
50 Tests Completed
Test 51 cut short
51 Tests Completed
52 Tests Completed
53 Tests Completed
54 Tests Completed
55 test failed
55 Tests Completed
56 test failed
56 Tests Completed
57 test failed
57 Tests Completed
58 test failed
58 Tests Completed
59 Tests Completed
60 Tests Completed
61 Tests Completed
62 Tests Completed
63 Tests Completed
64 Tests Completed
65 Tests Completed
66 Tests Completed
67 Tests Completed
68 test failed
68 Tests Completed
69 Tests Completed
70 Tests Completed
71 Tests Completed
Test 72 cut short
72 Tests Completed
73 Tests Completed
74 Tests Completed
Test 75 cut short
75 Tests Completed
Test 76 cut short
76 Tests Completed
77 Tests Completed
78 Tests Completed
79 Tests Completed
80 Tests Completed
81 Tests Completed
82 Tests Completed
Test 83 cut short
83 Tests Completed
Test 84 cut short
84 Tests Completed
Test 85 cut short
85 Tests Completed
Test 86 cut short
86 Tests Completed
87 Tests Completed
88 Tests Completed
Test 89 cut short
89 Tests Completed
90 Tests Completed
91 Tests Completed
92 Tests Completed
Test 93 cut short
93 Tests Completed
Test 94 cut short
94 Tests Completed
95 Tests Completed
Test 96 cut short
96 Tests Completed
Test 97 cut short
97 Tests Completed
98 Tests Completed
99 Tests Completed
100 Tests Completed
101 Tests Completed
Test 102 cut short
102 Tests Completed
103 Tests Completed
104 Tests Completed
105 Tests Completed
106 Tests Completed
107 Tests Completed
108 Tests Completed
Test 109 cut short
109 Tests Completed
110 Tests Completed
Test 111 cut short
111 Tests Completed
Test 112 cut short
112 Tests Completed
113 Tests Completed
Test 114 cut short
114 Tests Completed
Test 115 cut short
115 Tests Completed
Test 116 cut short
116 Tests Completed
Test 117 cut short
117 Tests Completed
Test 118 cut short
118 Tests Completed
Test 119 cut short
119 Tests Completed
Test 120 cut short
120 Tests Completed
Test 121 cut short
121 Tests Completed
122 Tests Completed
123 Tests Completed
124 Tests Completed
125 test failed
125 Tests Completed
126 test failed
126 Tests Completed
127 Tests Completed
128 Tests Completed
129 Tests Completed
Test 130 cut short
130 Tests Completed
Test 131 cut short
131 Tests Completed
Test 132 cut short
132 Tests Completed
Test 133 cut short
133 Tests Completed
134 Tests Completed
135 Tests Completed
136 Tests Completed
137 Tests Completed
Test 138 cut short
138 Tests Completed
139 Tests Completed
140 Tests Completed
141 Tests Completed
Test 142 cut short
142 Tests Completed
143 Tests Completed
144 Tests Completed
145 Tests Completed
146 Tests Completed
147 Tests Completed
148 Tests Completed
Test 149 cut short
149 Tests Completed
Test 150 cut short
150 Tests Completed
Test 151 cut short
151 Tests Completed
Test 152 cut short
152 Tests Completed
Test 153 cut short
153 Tests Completed
Test 154 cut short
154 Tests Completed
Test 155 cut short
155 Tests Completed
Test 156 cut short
156 Tests Completed
Test 157 cut short
157 Tests Completed
Test 158 cut short
158 Tests Completed
Test 159 cut short
159 Tests Completed
160 Tests Completed
161 Tests Completed
162 Tests Completed
163 Tests Completed
164 Tests Completed
165 Tests Completed
166 Tests Completed
167 Tests Completed
Test 168 cut short
168 Tests Completed
Test 169 cut short
169 Tests Completed
Test 170 cut short
170 Tests Completed
171 Tests Completed
172 Tests Completed
173 Tests Completed
174 Tests Completed
175 Tests Completed
Test 176 cut short
176 Tests Completed
177 Tests Completed
178 Tests Completed
179 Tests Completed
180 Tests Completed
Test 181 cut short
181 Tests Completed
Test 182 cut short
182 Tests Completed
183 Tests Completed
Test 184 cut short
184 Tests Completed
185 Tests Completed
186 Tests Completed
187 Tests Completed
188 Tests Completed
189 Tests Completed
Test 190 cut short
190 Tests Completed
191 Tests Completed
192 Tests Completed
193 Tests Completed
Test 194 cut short
194 Tests Completed
Test 195 cut short
195 Tests Completed
Test 196 cut short
196 Tests Completed
Test 197 cut short
197 Tests Completed
Test 198 cut short
198 Tests Completed
Test 199 cut short
199 Tests Completed
Test 200 cut short
200 Tests Completed
201 Tests Completed
202 Tests Completed
203 Tests Completed
204 Tests Completed
205 test failed
205 Tests Completed
206 test failed
206 Tests Completed
207 test failed
207 Tests Completed
208 test failed
208 Tests Completed
Test 209 cut short
209 Tests Completed
Test 210 cut short
210 Tests Completed
Test 211 cut short
211 Tests Completed
Test 212 cut short
212 Tests Completed
213 Tests Completed
214 Tests Completed
215 Tests Completed
Test 216 cut short
216 Tests Completed
217 Tests Completed
218 Tests Completed
219 Tests Completed
220 test failed
220 Tests Completed
221 test failed
221 Tests Completed
222 test failed
222 Tests Completed
223 Tests Completed
224 Tests Completed
225 Tests Completed
226 Tests Completed
Test 227 cut short
227 Tests Completed
228 Tests Completed
229 Tests Completed
230 test failed
230 Tests Completed
Test 231 cut short
231 Tests Completed
Test 232 cut short
232 Tests Completed
Test 233 cut short
233 Tests Completed
Test 234 cut short
234 Tests Completed
Test 235 cut short
235 Tests Completed
236 Tests Completed
237 Tests Completed
238 Tests Completed
239 test failed
239 Tests Completed
240 test failed
240 Tests Completed
241 Tests Completed
242 Tests Completed
243 Tests Completed
244 Tests Completed
245 test failed
245 Tests Completed
Test 246 cut short
246 Tests Completed
247 Tests Completed
248 Tests Completed
249 Tests Completed
250 Tests Completed
251 Tests Completed
252 Tests Completed
Test 253 cut short
253 Tests Completed
Test 254 cut short
254 Tests Completed
Test 255 cut short
255 Tests Completed
Test 256 cut short
256 Tests Completed
Test 257 cut short
257 Tests Completed
258 Tests Completed
Test 259 cut short
259 Tests Completed
Test 260 cut short
260 Tests Completed
261 Tests Completed
262 Tests Completed
Test 263 cut short
263 Tests Completed
264 Tests Completed
265 Tests Completed
266 Tests Completed
267 Tests Completed
Test 268 cut short
268 Tests Completed
Test 269 cut short
269 Tests Completed
Test 270 cut short
270 Tests Completed
Test 271 cut short
271 Tests Completed
Test 272 cut short
272 Tests Completed
273 Tests Completed
274 Tests Completed
275 test failed
275 Tests Completed
276 Tests Completed
Test 277 cut short
277 Tests Completed
278 Tests Completed
Test 279 cut short
279 Tests Completed
Test 280 cut short
280 Tests Completed
Test 281 cut short
281 Tests Completed
282 Tests Completed
283 Tests Completed
284 Tests Completed
285 Tests Completed
286 Tests Completed
287 test failed
287 Tests Completed
288 Tests Completed
289 Tests Completed
290 Tests Completed
291 Tests Completed
292 Tests Completed
293 Tests Completed
Test 294 cut short
294 Tests Completed
Test 295 cut short
295 Tests Completed
Test 296 cut short
296 Tests Completed
Test 297 cut short
297 Tests Completed
298 Tests Completed
299 Tests Completed
300 Tests Completed
301 test failed
301 Tests Completed
302 test failed
302 Tests Completed
303 test failed
303 Tests Completed
304 Tests Completed
Test 305 cut short
305 Tests Completed
Test 306 cut short
306 Tests Completed
Test 307 cut short
307 Tests Completed
Test 308 cut short
308 Tests Completed
309 Tests Completed
310 Tests Completed
311 Tests Completed
312 Tests Completed
313 Tests Completed
314 Tests Completed
Test 315 cut short
315 Tests Completed
316 Tests Completed
317 Tests Completed
Test 318 cut short
318 Tests Completed
319 Tests Completed
320 Tests Completed
321 Tests Completed
322 Tests Completed
323 Tests Completed
324 Tests Completed
325 Tests Completed
326 Tests Completed
327 Tests Completed
328 Tests Completed
329 Tests Completed
330 Tests Completed
331 Tests Completed
332 Tests Completed
333 Tests Completed
334 Tests Completed
335 Tests Completed
Test 336 cut short
336 Tests Completed
Test 337 cut short
337 Tests Completed
Test 338 cut short
338 Tests Completed
Test 339 cut short
339 Tests Completed
340 Tests Completed
341 Tests Completed
342 Tests Completed
343 Tests Completed
344 test failed
344 Tests Completed
345 Tests Completed
346 Tests Completed
347 test failed
347 Tests Completed
348 test failed
348 Tests Completed
349 test failed
349 Tests Completed
350 Tests Completed
351 Tests Completed
352 Tests Completed
353 Tests Completed
Test 354 cut short
354 Tests Completed
355 Tests Completed
Test 356 cut short
356 Tests Completed
357 Tests Completed
Test 358 cut short
358 Tests Completed
359 Tests Completed
Test 360 cut short
360 Tests Completed
Test 361 cut short
361 Tests Completed
Test 362 cut short
362 Tests Completed
Test 363 cut short
363 Tests Completed
364 Tests Completed
365 Tests Completed
366 Tests Completed
367 test failed
367 Tests Completed
368 test failed
368 Tests Completed
369 test failed
369 Tests Completed
370 test failed
370 Tests Completed
371 Tests Completed
372 Tests Completed
373 Tests Completed
374 test failed
374 Tests Completed
Test 375 cut short
375 Tests Completed
376 Tests Completed
377 Tests Completed
Test 378 cut short
378 Tests Completed
Test 379 cut short
379 Tests Completed
Test 380 cut short
380 Tests Completed
Test 381 cut short
381 Tests Completed
382 Tests Completed
383 Tests Completed
384 Tests Completed
385 test failed
385 Tests Completed
386 test failed
386 Tests Completed
387 Tests Completed
388 Tests Completed
389 Tests Completed
390 Tests Completed
391 Tests Completed
392 Tests Completed
Test 393 cut short
393 Tests Completed
Test 394 cut short
394 Tests Completed
Test 395 cut short
395 Tests Completed
396 Tests Completed
397 Tests Completed
398 Tests Completed
399 Tests Completed
Test 400 cut short
400 Tests Completed
Test 401 cut short
401 Tests Completed
Test 402 cut short
402 Tests Completed
Test 403 cut short
403 Tests Completed
Test 404 cut short
404 Tests Completed
405 Tests Completed
406 Tests Completed
407 Tests Completed
408 test failed
408 Tests Completed
409 Tests Completed
410 Tests Completed
411 Tests Completed
412 Tests Completed
413 Tests Completed
414 Tests Completed
415 Tests Completed
416 test failed
416 Tests Completed
417 Tests Completed
418 Tests Completed
419 Tests Completed
420 Tests Completed
421 test failed
421 Tests Completed
422 test failed
422 Tests Completed
Test 423 cut short
423 Tests Completed
Test 424 cut short
424 Tests Completed
Test 425 cut short
425 Tests Completed
Test 426 cut short
426 Tests Completed
Test 427 cut short
427 Tests Completed
Test 428 cut short
428 Tests Completed
429 Tests Completed
430 Tests Completed
431 Tests Completed
432 test failed
432 Tests Completed
433 Tests Completed
434 Tests Completed
435 Tests Completed
436 Tests Completed
437 Tests Completed
438 test failed
438 Tests Completed
Test 439 cut short
439 Tests Completed
Test 440 cut short
440 Tests Completed
Test 441 cut short
441 Tests Completed
442 Tests Completed
Test 443 cut short
443 Tests Completed
444 Tests Completed
445 Tests Completed
446 Tests Completed
447 test failed
447 Tests Completed
448 Tests Completed
449 Tests Completed
450 Tests Completed
Test 451 cut short
451 Tests Completed
452 Tests Completed
453 Tests Completed
Test 454 cut short
454 Tests Completed
Test 455 cut short
455 Tests Completed
Test 456 cut short
456 Tests Completed
457 Tests Completed
458 Tests Completed
459 Tests Completed
460 Tests Completed
461 Tests Completed
462 Tests Completed
463 Tests Completed
464 Tests Completed
465 Tests Completed
466 Tests Completed
467 Tests Completed
Test 468 cut short
468 Tests Completed
Test 469 cut short
469 Tests Completed
Test 470 cut short
470 Tests Completed
Test 471 cut short
471 Tests Completed
Test 472 cut short
472 Tests Completed
473 Tests Completed
474 Tests Completed
475 Tests Completed
476 Tests Completed
Test 477 cut short
477 Tests Completed
Test 478 cut short
478 Tests Completed
Test 479 cut short
479 Tests Completed
Test 480 cut short
480 Tests Completed
Test 481 cut short
481 Tests Completed
Test 482 cut short
482 Tests Completed
Test 483 cut short
483 Tests Completed
Test 484 cut short
484 Tests Completed
485 Tests Completed
486 Tests Completed
487 Tests Completed
488 Tests Completed
489 Tests Completed
490 Tests Completed
491 Tests Completed
Test 492 cut short
492 Tests Completed
Test 493 cut short
493 Tests Completed
Test 494 cut short
494 Tests Completed
Test 495 cut short
495 Tests Completed
Test 496 cut short
496 Tests Completed
497 Tests Completed
498 Tests Completed
499 test failed
499 Tests Completed

44 failures and 184 successful cases of mMine.
File 'dominion.c'
Lines executed:40.71% of 651
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:int compare(const void* a, const void* b) {
    35853:    9:	if (*(int*)a > *(int*)b)
     3102:   10:		return 1;
    32751:   11:	if (*(int*)a < *(int*)b)
    12579:   12:		return -1;
    20172:   13:	return 0;
    35853:   14:}
        -:   15:
        -:   16:struct gameState* newGame() {
    #####:   17:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:	return g;
        -:   19:}
        -:   20:
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		int k8, int k9, int k10) {
    #####:   23:	int* k = malloc(10 * sizeof(int));
    #####:   24:	k[0] = k1;
    #####:   25:	k[1] = k2;
    #####:   26:	k[2] = k3;
    #####:   27:	k[3] = k4;
    #####:   28:	k[4] = k5;
    #####:   29:	k[5] = k6;
    #####:   30:	k[6] = k7;
    #####:   31:	k[7] = k8;
    #####:   32:	k[8] = k9;
    #####:   33:	k[9] = k10;
    #####:   34:	return k;
        -:   35:}
        -:   36:
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;			
        -:   43:	//set up random number generator
     1515:   44:	SelectStream(1);
     1515:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
     3030:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
      767:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
      748:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
    16456:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
   164560:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
   142120:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
    74800:   65:		}
     7480:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
      748:   73:	if (numPlayers == 2)
        -:   74:	{
      346:   75:		state->supplyCount[curse] = 10;
      346:   76:	}
      402:   77:	else if (numPlayers == 3)
        -:   78:	{
      387:   79:		state->supplyCount[curse] = 20;
      387:   80:	}
        -:   81:	else
        -:   82:	{
       15:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
      748:   87:	if (numPlayers == 2)
        -:   88:	{
      346:   89:		state->supplyCount[estate] = 8;
      346:   90:		state->supplyCount[duchy] = 8;
      346:   91:		state->supplyCount[province] = 8;
      346:   92:	}
        -:   93:	else
        -:   94:	{
      402:   95:		state->supplyCount[estate] = 12;
      402:   96:		state->supplyCount[duchy] = 12;
      402:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
      748:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
      748:  102:	state->supplyCount[silver] = 40;
      748:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
    31416:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
   246840:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
   115940:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
    14960:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
      748:  115:					if (numPlayers == 2){ 
      346:  116:						state->supplyCount[i] = 8; 
      346:  117:					}
      402:  118:					else{ state->supplyCount[i] = 12; }
      748:  119:				}
        -:  120:				else
        -:  121:				{
     6732:  122:					state->supplyCount[i] = 10;
        -:  123:				}
     7480:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
   108460:  128:				state->supplyCount[i] = -1;
        -:  129:			}
   108460:  130:		}
        -:  131:
    14960:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
     5322:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
     1913:  140:		state->deckCount[i] = 0;
    15304:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
     5739:  143:			state->deck[i][j] = estate;
     5739:  144:			state->deckCount[i]++;
     5739:  145:		}
    30608:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
    13391:  148:			state->deck[i][j] = copper;
    13391:  149:			state->deckCount[i]++;		
    13391:  150:		}
     1913:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
     5322:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
     1913:  156:		if ( shuffle(i, state) < 0 )
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
     1913:  160:	}
        -:  161:
        -:  162:	//draw player hands
     5322:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{  
        -:  165:		//initialize hand size to zero
     1913:  166:		state->handCount[i] = 0;
     1913:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
     1913:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
    41888:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
    20196:  178:		state->embargoTokens[i] = 0;
    20196:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
      748:  182:	state->outpostPlayed = 0;
      748:  183:	state->phase = 0;
      748:  184:	state->numActions = 1;
      748:  185:	state->numBuys = 1;
      748:  186:	state->playedCardCount = 0;
      748:  187:	state->whoseTurn = 0;
      748:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
     8976:  192:	for (it = 0; it < 5; it++){
     3740:  193:		drawCard(state->whoseTurn, state);
     3740:  194:	}
        -:  195:
      748:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
      748:  198:	return 0;
     1515:  199:}
        -:  200:
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
     2600:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
     2600:  209:	if (state->deckCount[player] < 1)
      676:  210:		return -1;
     1924:  211:	qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    48074:  214:	while (state->deckCount[player] > 0) {
    22113:  215:		card = floor(Random() * state->deckCount[player]);
    22113:  216:		newDeck[newDeckPos] = state->deck[player][card];
    22113:  217:		newDeckPos++;
   634840:  218:		for (i = card; i < state->deckCount[player]-1; i++) {
   295307:  219:			state->deck[player][i] = state->deck[player][i+1];
   295307:  220:		}
    22113:  221:		state->deckCount[player]--;
        -:  222:	}
    48074:  223:	for (i = 0; i < newDeckPos; i++) {
    22113:  224:		state->deck[player][i] = newDeck[i];
    22113:  225:		state->deckCount[player]++;
    22113:  226:	}
        -:  227:
     1924:  228:	return 0;
     2600:  229:}
        -:  230:
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:	int card;
       60:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
       60:  237:	if (state->phase != 0)
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
       60:  243:	if ( state->numActions < 1 )
        -:  244:	{
    #####:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
       60:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      120:  252:	if ( card < adventurer || card > treasure_map )
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       60:  258:	if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       60:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       60:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       60:  269:	return 0;
       60:  270:}
        -:  271:
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
    #####:  280:	who = state->whoseTurn;
        -:  281:
    #####:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
    #####:  285:		return -1;
    #####:  286:	} else if (supplyCount(supplyPos, state) <1){
        -:  287:		if (DEBUG)
        -:  288:			printf("There are not any of that type of card left\n");
    #####:  289:		return -1;
    #####:  290:	} else if (state->coins < getCost(supplyPos)){
        -:  291:		if (DEBUG) 
        -:  292:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:		return -1;
        -:  294:	} else {
    #####:  295:		state->phase=1;
        -:  296:		//state->supplyCount[supplyPos]--;
    #####:  297:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  298:
    #####:  299:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  300:		state->numBuys--;
        -:  301:		if (DEBUG)
        -:  302:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:	}
        -:  304:
        -:  305:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:	//state->discardCount[who]++;
        -:  307:
    #####:  308:	return 0;
    #####:  309:}
        -:  310:
        -:  311:int numHandCards(struct gameState *state) {
    #####:  312:	return state->handCount[ whoseTurn(state) ];
        -:  313:}
        -:  314:
        -:  315:int handCard(int handPos, struct gameState *state) {
       60:  316:	int currentPlayer = whoseTurn(state);
       60:  317:	return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
        -:  320:int supplyCount(int card, struct gameState *state) {
      405:  321:	return state->supplyCount[card];
        -:  322:}
        -:  323:
        -:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:	int i;
    #####:  326:	int count = 0;
        -:  327:
    #####:  328:	for (i = 0; i < state->deckCount[player]; i++)
        -:  329:	{
    #####:  330:		if (state->deck[player][i] == card) count++;
    #####:  331:	}
        -:  332:
    #####:  333:	for (i = 0; i < state->handCount[player]; i++)
        -:  334:	{
    #####:  335:		if (state->hand[player][i] == card) count++;
    #####:  336:	}
        -:  337:
    #####:  338:	for (i = 0; i < state->discardCount[player]; i++)
        -:  339:	{
    #####:  340:		if (state->discard[player][i] == card) count++;
    #####:  341:	}
        -:  342:
    #####:  343:	return count;
        -:  344:}
        -:  345:
        -:  346:int whoseTurn(struct gameState *state) {
     2740:  347:	return state->whoseTurn;
        -:  348:}
        -:  349:
        -:  350:int endTurn(struct gameState *state) {
        -:  351:	int k;
        -:  352:	int i;
    #####:  353:	int currentPlayer = whoseTurn(state);
        -:  354:
        -:  355:	//Discard hand
    #####:  356:	for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  357:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:		state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  359:	}
    #####:  360:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:
        -:  362:	//Code for determining the player
    #####:  363:	if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  364:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  365:	}
        -:  366:	else{
    #####:  367:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:	}
        -:  369:
    #####:  370:	state->outpostPlayed = 0;
    #####:  371:	state->phase = 0;
    #####:  372:	state->numActions = 1;
    #####:  373:	state->coins = 0;
    #####:  374:	state->numBuys = 1;
    #####:  375:	state->playedCardCount = 0;
    #####:  376:	state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:	//int k; move to top
        -:  379:	//Next player draws hand
    #####:  380:	for (k = 0; k < 5; k++){
    #####:  381:		drawCard(state->whoseTurn, state);//Draw a card
    #####:  382:	}
        -:  383:
        -:  384:	//Update money
    #####:  385:	updateCoins(state->whoseTurn, state , 0);
        -:  386:
    #####:  387:	return 0;
        -:  388:}
        -:  389:
        -:  390:int isGameOver(struct gameState *state) {
        -:  391:	int i;
        -:  392:	int j;
        -:  393:
        -:  394:	//if stack of Province cards is empty, the game ends
    #####:  395:	if (state->supplyCount[province] == 0)
        -:  396:	{
    #####:  397:		return 1;
        -:  398:	}
        -:  399:
        -:  400:	//if three supply pile are at 0, the game ends
    #####:  401:	j = 0;
    #####:  402:	for (i = 0; i < 25; i++)
        -:  403:	{
    #####:  404:		if (state->supplyCount[i] == 0)
        -:  405:		{
    #####:  406:			j++;
    #####:  407:		}
    #####:  408:	}
    #####:  409:	if ( j >= 3)
        -:  410:	{
    #####:  411:		return 1;
        -:  412:	}
        -:  413:
    #####:  414:	return 0;
    #####:  415:}
        -:  416:
        -:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:	int i;
    #####:  420:	int score = 0;
        -:  421:	//score from hand
    #####:  422:	for (i = 0; i < state->handCount[player]; i++)
        -:  423:	{
    #####:  424:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  425:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  426:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  427:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  428:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  430:	}
        -:  431:
        -:  432:	//score from discard
    #####:  433:	for (i = 0; i < state->discardCount[player]; i++)
        -:  434:	{
    #####:  435:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  436:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  437:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  438:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  439:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  441:	}
        -:  442:
        -:  443:	//score from deck
    #####:  444:	for (i = 0; i < state->discardCount[player]; i++)
        -:  445:	{
    #####:  446:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  447:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  448:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  449:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  450:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    #####:  452:	}
        -:  453:
    #####:  454:	return score;
        -:  455:}
        -:  456:
        -:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:	int i;	
        -:  459:	int j;
        -:  460:	int highScore;
        -:  461:	int currentPlayer;
        -:  462:
        -:  463:	//get score for each player
    #####:  464:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  465:	{
        -:  466:		//set unused player scores to -9999
    #####:  467:		if (i >= state->numPlayers)
        -:  468:		{
    #####:  469:			players[i] = -9999;
    #####:  470:		}
        -:  471:		else
        -:  472:		{
    #####:  473:			players[i] = scoreFor (i, state);
        -:  474:		}
    #####:  475:	}
        -:  476:
        -:  477:	//find highest score
    #####:  478:	j = 0;
    #####:  479:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  480:	{
    #####:  481:		if (players[i] > players[j])
        -:  482:		{
    #####:  483:			j = i;
    #####:  484:		}
    #####:  485:	}
    #####:  486:	highScore = players[j];
        -:  487:
        -:  488:	//add 1 to players who had less turns
    #####:  489:	currentPlayer = whoseTurn(state);
    #####:  490:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  491:	{
    #####:  492:		if ( players[i] == highScore && i > currentPlayer )
        -:  493:		{
    #####:  494:			players[i]++;
    #####:  495:		}
    #####:  496:	}
        -:  497:
        -:  498:	//find new highest score
    #####:  499:	j = 0;
    #####:  500:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  501:	{
    #####:  502:		if ( players[i] > players[j] )
        -:  503:		{
    #####:  504:			j = i;
    #####:  505:		}
    #####:  506:	}
    #####:  507:	highScore = players[j];
        -:  508:
        -:  509:	//set winners in array to 1 and rest to 0
    #####:  510:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  511:	{
    #####:  512:		if ( players[i] == highScore )
        -:  513:		{
    #####:  514:			players[i] = 1;
    #####:  515:		}
        -:  516:		else
        -:  517:		{
    #####:  518:			players[i] = 0;
        -:  519:		}
    #####:  520:	}
        -:  521:
    #####:  522:	return 0;
        -:  523:}
        -:  524:
        -:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:	int deckCounter;
    12466:  528:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  529:
        -:  530:		//Step 1 Shuffle the discard pile back into a deck
        -:  531:		int i;
        -:  532:		//Move discard to deck
     7330:  533:		for (i = 0; i < state->discardCount[player];i++){
     2983:  534:			state->deck[player][i] = state->discard[player][i];
     2983:  535:			state->discard[player][i] = -1;
     2983:  536:		}
        -:  537:
      682:  538:		state->deckCount[player] = state->discardCount[player];
      682:  539:		state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:		//Shufffle the deck
      682:  542:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  543:
        -:  544:		if (DEBUG){//Debug statements
        -:  545:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:		}
        -:  547:
      682:  548:		state->discardCount[player] = 0;
        -:  549:
        -:  550:		//Step 2 Draw Card
      682:  551:		count = state->handCount[player];//Get current player's hand count
        -:  552:
        -:  553:		if (DEBUG){//Debug statements
        -:  554:			printf("Current hand count: %d\n", count);
        -:  555:		}
        -:  556:
      682:  557:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
      682:  559:		if (deckCounter == 0)
      671:  560:			return -1;
        -:  561:
       11:  562:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       11:  563:		state->deckCount[player]--;
       11:  564:		state->handCount[player]++;//Increment hand count
       11:  565:	}
        -:  566:
        -:  567:	else{
    11784:  568:		int count = state->handCount[player];//Get current hand count for player
        -:  569:		int deckCounter;
        -:  570:		if (DEBUG){//Debug statements
        -:  571:			printf("Current hand count: %d\n", count);
        -:  572:		}
        -:  573:
    11784:  574:		deckCounter = state->deckCount[player];//Create holder for the deck count
    11784:  575:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    11784:  576:		state->deckCount[player]--;
    11784:  577:		state->handCount[player]++;//Increment hand count
        -:  578:	}
        -:  579:
    11795:  580:	return 0;
    12466:  581:}
        -:  582:
        -:  583:int getCost(int cardNumber)
        -:  584:{
     1060:  585:	switch( cardNumber ) 
        -:  586:	{
        -:  587:		case curse:
       90:  588:			return 0;
        -:  589:		case estate:
      171:  590:			return 2;
        -:  591:		case duchy:
    #####:  592:			return 5;
        -:  593:		case province:
    #####:  594:			return 8;
        -:  595:		case copper:
      285:  596:			return 0;
        -:  597:		case silver:
      500:  598:			return 3;
        -:  599:		case gold:
    #####:  600:			return 6;
        -:  601:		case adventurer:
    #####:  602:			return 6;
        -:  603:		case council_room:
    #####:  604:			return 5;
        -:  605:		case feast:
    #####:  606:			return 4;
        -:  607:		case gardens:
    #####:  608:			return 4;
        -:  609:		case mine:
    #####:  610:			return 5;
        -:  611:		case remodel:
    #####:  612:			return 4;
        -:  613:		case smithy:
    #####:  614:			return 4;
        -:  615:		case village:
    #####:  616:			return 3;
        -:  617:		case baron:
    #####:  618:			return 4;
        -:  619:		case great_hall:
    #####:  620:			return 3;
        -:  621:		case minion:
    #####:  622:			return 5;
        -:  623:		case steward:
    #####:  624:			return 3;
        -:  625:		case tribute:
    #####:  626:			return 5;
        -:  627:		case ambassador:
    #####:  628:			return 3;
        -:  629:		case cutpurse:
    #####:  630:			return 4;
        -:  631:		case embargo: 
    #####:  632:			return 2;
        -:  633:		case outpost:
    #####:  634:			return 5;
        -:  635:		case salvager:
    #####:  636:			return 4;
        -:  637:		case sea_hag:
    #####:  638:			return 4;
        -:  639:		case treasure_map:
    #####:  640:			return 4;
        -:  641:	}
        -:  642:
       14:  643:	return -1;
     1060:  644:}
        -:  645:/************************************ REFACTOR FUNCTIONS **************************************/
        -:  646:
        -:  647:int Adventurer(struct gameState *state) {
       60:  648:	int drawntreasure = 0;
       60:  649:	int currentPlayer = whoseTurn(state);
        -:  650:	int cardDrawn; 
        -:  651:	int temphand[MAX_HAND];
       60:  652:	int z = 0; //temphand counter 
        -:  653:
        -:  654:	//bug here
     4732:  655:	while(drawntreasure<5){
     2306:  656:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
        5:  657:			shuffle(currentPlayer, state);
        5:  658:		}
     2306:  659:		drawCard(currentPlayer, state);
     2306:  660:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     6628:  661:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
      300:  662:			drawntreasure++;
        -:  663:		else{
     2006:  664:			temphand[z]=cardDrawn;
     2006:  665:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     2006:  666:			z++;
        -:  667:		}
        -:  668:	}
     4132:  669:	while(z-1>=0){
     2006:  670:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     2006:  671:		z=z-1;
        -:  672:	}
       60:  673:	return 0;
        -:  674:}
        -:  675:
        -:  676:int Smithy(struct gameState *state, int handPos) {
        -:  677:	//+3 Cards
     1000:  678:	int currentPlayer = whoseTurn(state);
        -:  679:
        -:  680:	//bug here 3 -> 5
    12000:  681:	for (int i = 0; i < 5; i++) {
     5000:  682:		drawCard(currentPlayer, state);
     5000:  683:	}
        -:  684:
        -:  685:	//discard card from hand
     1000:  686:	discardCard(handPos, currentPlayer, state, 0);
     1000:  687:	return 0;
        -:  688:}
        -:  689:
        -:  690:int CouncilRoom(struct gameState *state, int handPos){
       60:  691:	int currentPlayer = whoseTurn(state);
        -:  692:
        -:  693:	//+4 Cards
      600:  694:	for (int i = 0; i < 4; i++) {
      240:  695:		drawCard(currentPlayer, state);
      240:  696:	}
        -:  697:
        -:  698:	//+1 Buy
        -:  699:	//bug here: +3 buys instead of 1 
       60:  700:	state->numBuys + 3;
        -:  701:
        -:  702:	//Each other player draws a card
      600:  703:	for (int i = 0; i < state->numPlayers; i++) {
      240:  704:		if ( i != currentPlayer ) {
      180:  705:			drawCard(i, state);
      180:  706:		}
      240:  707:	}
        -:  708:
        -:  709:	//put played card in played card pile
       60:  710:	discardCard(handPos, currentPlayer, state, 0);
        -:  711:
       60:  712:	return 0;
        -:  713:}
        -:  714:
        -:  715:int GreatHall(struct gameState *state, int handPos){
        -:  716:
    #####:  717:	int currentPlayer = whoseTurn(state);
        -:  718:
        -:  719:	//+1 Card
    #####:  720:	drawCard(currentPlayer, state);
        -:  721:
        -:  722:	//+1 Actions
        -:  723:	//Bug here: gives 4 more actions
    #####:  724:	state->numActions + 4;
        -:  725:
        -:  726:	//discard card from hand
    #####:  727:	discardCard(handPos, currentPlayer, state, 0);
    #####:  728:	return 0;
        -:  729:}
        -:  730:
        -:  731:int Minion(struct gameState *state, int handPos, int choice1, int choice2) {
    #####:  732:	int currentPlayer = whoseTurn(state);		
        -:  733:	//+1 action
    #####:  734:	state->numActions++;
        -:  735:
        -:  736:	//discard card from hand
    #####:  737:	discardCard(handPos, currentPlayer, state, 0);
        -:  738:
        -:  739:	//bug here: changed from choice1 to choice2
    #####:  740:	if (choice2)		//+2 coins
        -:  741:	{
    #####:  742:		state->coins = state->coins + 2;
    #####:  743:	}
        -:  744:
    #####:  745:	else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  746:	{
        -:  747:		//discard hand
    #####:  748:		while(numHandCards(state) > 0)
        -:  749:		{
    #####:  750:			discardCard(handPos, currentPlayer, state, 0);
        -:  751:		}
        -:  752:
        -:  753:		//draw 4
    #####:  754:		for (int i = 0; i < 4; i++)
        -:  755:		{
    #####:  756:			drawCard(currentPlayer, state);
    #####:  757:		}
        -:  758:
        -:  759:		//other players discard hand and redraw if hand size > 4
    #####:  760:		for (int i = 0; i < state->numPlayers; i++)
        -:  761:		{
    #####:  762:			if (i != currentPlayer)
        -:  763:			{
    #####:  764:				if ( state->handCount[i] > 4 )
        -:  765:				{
        -:  766:					//discard hand
    #####:  767:					while( state->handCount[i] > 0 )
        -:  768:					{
    #####:  769:						discardCard(handPos, i, state, 0);
        -:  770:					}
        -:  771:
        -:  772:					//draw 4
    #####:  773:					for (int j = 0; j < 4; j++)
        -:  774:					{
    #####:  775:						drawCard(i, state);
    #####:  776:					}
    #####:  777:				}
    #####:  778:			}
    #####:  779:		}
        -:  780:
    #####:  781:	}
    #####:  782:	return 0;
        -:  783:}
        -:  784:
        -:  785:
        -:  786:
        -:  787:
        -:  788:/************************************ END OF REFACTORING *****************************************/
        -:  789:
        -:  790:
        -:  791:
        -:  792:
        -:  793:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  794:{
        -:  795:	int i;
        -:  796:	int j;
        -:  797:	int k;
        -:  798:	int x;
        -:  799:	int index;
     1560:  800:	int currentPlayer = whoseTurn(state);
     1560:  801:	int nextPlayer = currentPlayer + 1;
        -:  802:
     1560:  803:	int tributeRevealedCards[2] = {-1, -1};
        -:  804:	int temphand[MAX_HAND];// moved above the if statement
        -:  805:
        -:  806:	//3 vars below were not used in compilation, so commented out
     1560:  807:	int drawntreasure=0;
        -:  808:	int cardDrawn;
     1560:  809:	int z = 0;// this is the counter for the temp hand
     1560:  810:	if (nextPlayer > (state->numPlayers - 1)){
       15:  811:		nextPlayer = 0;
       15:  812:	}
        -:  813:
        -:  814:
        -:  815:	//uses switch to select card and perform actions
     2680:  816:	switch( card ) 
        -:  817:	{		
        -:  818:		//Refactored above
        -:  819:		case adventurer:
       60:  820:			Adventurer(state);
        -:  821:
        -:  822:			/*
        -:  823:			   while(drawntreasure<2){
        -:  824:			   if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
        -:  825:			   shuffle(currentPlayer, state);
        -:  826:			   }
        -:  827:			   drawCard(currentPlayer, state);
        -:  828:			   cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
        -:  829:			   if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:  830:			   drawntreasure++;
        -:  831:			   else{
        -:  832:			   temphand[z]=cardDrawn;
        -:  833:			   state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        -:  834:			   z++;
        -:  835:			   }
        -:  836:			   }
        -:  837:			   while(z-1>=0){
        -:  838:			   state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
        -:  839:			   z=z-1;
        -:  840:			   }
        -:  841:			   return 0;
        -:  842:			  */ 
        -:  843:
        -:  844:		case council_room:
       60:  845:			CouncilRoom(state, handPos);
        -:  846:			/*
        -:  847:			//+4 Cards
        -:  848:			for (i = 0; i < 4; i++)
        -:  849:			{
        -:  850:			drawCard(currentPlayer, state);
        -:  851:			}
        -:  852:
        -:  853:			//+1 Buy
        -:  854:			state->numBuys++;
        -:  855:
        -:  856:			//Each other player draws a card
        -:  857:			for (i = 0; i < state->numPlayers; i++)
        -:  858:			{
        -:  859:			if ( i != currentPlayer )
        -:  860:			{
        -:  861:			drawCard(i, state);
        -:  862:			}
        -:  863:			}
        -:  864:
        -:  865:			//put played card in played card pile
        -:  866:			discardCard(handPos, currentPlayer, state, 0);
        -:  867:
        -:  868:			return 0;
        -:  869:			*/
        -:  870:
        -:  871:		case feast:
        -:  872:			//gain card with cost up to 5
        -:  873:			//Backup hand
    30068:  874:			for (i = 0; i <= state->handCount[currentPlayer]; i++){
    14974:  875:				temphand[i] = state->hand[currentPlayer][i];//Backup card
    14974:  876:				state->hand[currentPlayer][i] = -1;//Set to nothing
    14974:  877:			}
        -:  878:			//Backup hand
        -:  879:
        -:  880:			//Update Coins for Buy
       60:  881:			updateCoins(currentPlayer, state, 5);
       60:  882:			x = 1;//Condition to loop on
      240:  883:			while( x == 1) {//Buy one card
       60:  884:				if (supplyCount(choice1, state) <= 0){
        -:  885:					if (DEBUG)
        -:  886:						printf("None of that card left, sorry!\n");
        -:  887:
        -:  888:					if (DEBUG){
        -:  889:						printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  890:					}
    #####:  891:				}
       60:  892:				else if (state->coins < getCost(choice1)){
    #####:  893:					printf("That card is too expensive!\n");
        -:  894:
        -:  895:					if (DEBUG){
        -:  896:						printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  897:					}
    #####:  898:				}
        -:  899:				else{
        -:  900:
        -:  901:					if (DEBUG){
        -:  902:						printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  903:					}
        -:  904:
       60:  905:					gainCard(choice1, state, 0, currentPlayer);//Gain the card
       60:  906:					x = 0;//No more buying cards
        -:  907:
        -:  908:					if (DEBUG){
        -:  909:						printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  910:					}
        -:  911:
        -:  912:				}
        -:  913:			}     
        -:  914:
        -:  915:			//Reset Hand
    30068:  916:			for (i = 0; i <= state->handCount[currentPlayer]; i++){
    14974:  917:				state->hand[currentPlayer][i] = temphand[i];
    14974:  918:				temphand[i] = -1;
    14974:  919:			}
        -:  920:			//Reset Hand
        -:  921:
       60:  922:			return 0;
        -:  923:
        -:  924:		case gardens:
    #####:  925:			return -1;
        -:  926:
        -:  927:		case mine:
      500:  928:			j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  929:
      785:  930:			if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  931:			{
      215:  932:				return -1;
        -:  933:			}
        -:  934:
      570:  935:			if (choice2 > treasure_map || choice2 < curse)
        -:  936:			{
    #####:  937:				return -1;
        -:  938:			}
        -:  939:
      285:  940:			if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  941:			{
    #####:  942:				return -1;
        -:  943:			}
        -:  944:
      285:  945:			gainCard(choice2, state, 2, currentPlayer);
        -:  946:
        -:  947:			//discard card from hand
      285:  948:			discardCard(handPos, currentPlayer, state, 0);
        -:  949:
        -:  950:			//discard trashed card
     1772:  951:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  952:			{
      885:  953:				if (state->hand[currentPlayer][i] == j)
        -:  954:				{
      284:  955:					discardCard(i, currentPlayer, state, 0);			
      284:  956:					break;
        -:  957:				}
      601:  958:			}
        -:  959:
      285:  960:			return 0;
        -:  961:
        -:  962:		case remodel:
    #####:  963:			j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  964:
    #####:  965:			if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  966:			{
    #####:  967:				return -1;
        -:  968:			}
        -:  969:
    #####:  970:			gainCard(choice2, state, 0, currentPlayer);
        -:  971:
        -:  972:			//discard card from hand
    #####:  973:			discardCard(handPos, currentPlayer, state, 0);
        -:  974:
        -:  975:			//discard trashed card
    #####:  976:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  977:			{
    #####:  978:				if (state->hand[currentPlayer][i] == j)
        -:  979:				{
    #####:  980:					discardCard(i, currentPlayer, state, 0);			
    #####:  981:					break;
        -:  982:				}
    #####:  983:			}
        -:  984:
        -:  985:
    #####:  986:			return 0;
        -:  987:
        -:  988:		case smithy:
     1000:  989:			Smithy(state, handPos); 
        -:  990:			
        -:  991:			/*
        -:  992:			//+3 Cards
        -:  993:			for (i = 0; i < 3; i++)
        -:  994:			{
        -:  995:			drawCard(currentPlayer, state);
        -:  996:			}
        -:  997:
        -:  998:			//discard card from hand
        -:  999:			discardCard(handPos, currentPlayer, state, 0);
        -: 1000:			return 0;
        -: 1001:			*/
        -: 1002:
        -: 1003:		case village:
        -: 1004:			//+1 Card
     1000: 1005:			drawCard(currentPlayer, state);
        -: 1006:
        -: 1007:			//+2 Actions
     1000: 1008:			state->numActions = state->numActions + 2;
        -: 1009:
        -: 1010:			//discard played card from hand
     1000: 1011:			discardCard(handPos, currentPlayer, state, 0);
     1000: 1012:			return 0;
        -: 1013:
        -: 1014:		case baron:
    #####: 1015:			state->numBuys++;//Increase buys by 1!
    #####: 1016:			if (choice1 > 0){//Boolean true or going to discard an estate
    #####: 1017:				int p = 0;//Iterator for hand!
    #####: 1018:				int card_not_discarded = 1;//Flag for discard set!
    #####: 1019:				while(card_not_discarded){
    #####: 1020:					if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####: 1021:						state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1022:						state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1023:						state->discardCount[currentPlayer]++;
    #####: 1024:						for (;p < state->handCount[currentPlayer]; p++){
    #####: 1025:							state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####: 1026:						}
    #####: 1027:						state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1028:						state->handCount[currentPlayer]--;
    #####: 1029:						card_not_discarded = 0;//Exit the loop
    #####: 1030:					}
    #####: 1031:					else if (p > state->handCount[currentPlayer]){
        -: 1032:						if(DEBUG) {
        -: 1033:							printf("No estate cards in your hand, invalid choice\n");
        -: 1034:							printf("Must gain an estate if there are any\n");
        -: 1035:						}
    #####: 1036:						if (supplyCount(estate, state) > 0){
    #####: 1037:							gainCard(estate, state, 0, currentPlayer);
    #####: 1038:							state->supplyCount[estate]--;//Decrement estates
    #####: 1039:							if (supplyCount(estate, state) == 0){
    #####: 1040:								isGameOver(state);
    #####: 1041:							}
    #####: 1042:						}
    #####: 1043:						card_not_discarded = 0;//Exit the loop
    #####: 1044:					}
        -: 1045:
        -: 1046:					else{
    #####: 1047:						p++;//Next card
        -: 1048:					}
        -: 1049:				}
    #####: 1050:			}
        -: 1051:
        -: 1052:			else{
    #####: 1053:				if (supplyCount(estate, state) > 0){
    #####: 1054:					gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####: 1055:					state->supplyCount[estate]--;//Decrement Estates
    #####: 1056:					if (supplyCount(estate, state) == 0){
    #####: 1057:						isGameOver(state);
    #####: 1058:					}
    #####: 1059:				}
        -: 1060:			}
        -: 1061:
        -: 1062:
    #####: 1063:			return 0;
        -: 1064:
        -: 1065:		case great_hall:
    #####: 1066:			GreatHall(state, handPos);
        -: 1067:			/*
        -: 1068:			//+1 Card
        -: 1069:			drawCard(currentPlayer, state);
        -: 1070:
        -: 1071:			//+1 Actions
        -: 1072:			state->numActions++;
        -: 1073:
        -: 1074:			//discard card from hand
        -: 1075:			discardCard(handPos, currentPlayer, state, 0);
        -: 1076:			return 0;
        -: 1077:			*/
        -: 1078:
        -: 1079:		case minion:
    #####: 1080:			Minion(state, handPos, choice1, choice2);
        -: 1081:			/*
        -: 1082:			//+1 action
        -: 1083:			state->numActions++;
        -: 1084:
        -: 1085:			//discard card from hand
        -: 1086:			discardCard(handPos, currentPlayer, state, 0);
        -: 1087:
        -: 1088:			if (choice1)		//+2 coins
        -: 1089:			{
        -: 1090:			state->coins = state->coins + 2;
        -: 1091:			}
        -: 1092:
        -: 1093:			else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -: 1094:			{
        -: 1095:			//discard hand
        -: 1096:			while(numHandCards(state) > 0)
        -: 1097:			{
        -: 1098:			discardCard(handPos, currentPlayer, state, 0);
        -: 1099:			}
        -: 1100:
        -: 1101:			//draw 4
        -: 1102:			for (i = 0; i < 4; i++)
        -: 1103:			{
        -: 1104:			drawCard(currentPlayer, state);
        -: 1105:			}
        -: 1106:
        -: 1107:			//other players discard hand and redraw if hand size > 4
        -: 1108:			for (i = 0; i < state->numPlayers; i++)
        -: 1109:			{
        -: 1110:			if (i != currentPlayer)
        -: 1111:			{
        -: 1112:			if ( state->handCount[i] > 4 )
        -: 1113:			{
        -: 1114:			//discard hand
        -: 1115:			while( state->handCount[i] > 0 )
        -: 1116:			{
        -: 1117:			discardCard(handPos, i, state, 0);
        -: 1118:			}
        -: 1119:
        -: 1120:			//draw 4
        -: 1121:			for (j = 0; j < 4; j++)
        -: 1122:			{
        -: 1123:			drawCard(i, state);
        -: 1124:			}
        -: 1125:			}
        -: 1126:			}
        -: 1127:			}
        -: 1128:
        -: 1129:			}
        -: 1130:			return 0;
        -: 1131:			*/
        -: 1132:
        -: 1133:		case steward:
    #####: 1134:			if (choice1 == 1)
        -: 1135:			{
        -: 1136:				//+2 cards
    #####: 1137:				drawCard(currentPlayer, state);
    #####: 1138:				drawCard(currentPlayer, state);
    #####: 1139:			}
    #####: 1140:			else if (choice1 == 2)
        -: 1141:			{
        -: 1142:				//+2 coins
    #####: 1143:				state->coins = state->coins + 2;
    #####: 1144:			}
        -: 1145:			else
        -: 1146:			{
        -: 1147:				//trash 2 cards in hand
    #####: 1148:				discardCard(choice2, currentPlayer, state, 1);
    #####: 1149:				discardCard(choice3, currentPlayer, state, 1);
        -: 1150:			}
        -: 1151:
        -: 1152:			//discard card from hand
    #####: 1153:			discardCard(handPos, currentPlayer, state, 0);
    #####: 1154:			return 0;
        -: 1155:
        -: 1156:		case tribute:
    #####: 1157:			if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1158:				if (state->deckCount[nextPlayer] > 0){
    #####: 1159:					tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1160:					state->deckCount[nextPlayer]--;
    #####: 1161:				}
    #####: 1162:				else if (state->discardCount[nextPlayer] > 0){
    #####: 1163:					tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1164:					state->discardCount[nextPlayer]--;
    #####: 1165:				}
        -: 1166:				else{
        -: 1167:					//No Card to Reveal
        -: 1168:					if (DEBUG){
        -: 1169:						printf("No cards to reveal\n");
        -: 1170:					}
        -: 1171:				}
    #####: 1172:			}
        -: 1173:
        -: 1174:			else{
    #####: 1175:				if (state->deckCount[nextPlayer] == 0){
    #####: 1176:					for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1177:						state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1178:						state->deckCount[nextPlayer]++;
    #####: 1179:						state->discard[nextPlayer][i] = -1;
    #####: 1180:						state->discardCount[nextPlayer]--;
    #####: 1181:					}
        -: 1182:
    #####: 1183:					shuffle(nextPlayer,state);//Shuffle the deck
    #####: 1184:				} 
    #####: 1185:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1186:				state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1187:				state->deckCount[nextPlayer]--;
    #####: 1188:				tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1189:				state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1190:				state->deckCount[nextPlayer]--;
        -: 1191:			}    
        -: 1192:
    #####: 1193:			if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1194:				state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1195:				state->playedCardCount++;
    #####: 1196:				tributeRevealedCards[1] = -1;
    #####: 1197:			}
        -: 1198:
    #####: 1199:			for (i = 0; i <= 2; i ++){
    #####: 1200:				if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1201:					state->coins += 2;
    #####: 1202:				}
        -: 1203:
    #####: 1204:				else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1205:					drawCard(currentPlayer, state);
    #####: 1206:					drawCard(currentPlayer, state);
    #####: 1207:				}
        -: 1208:				else{//Action Card
    #####: 1209:					state->numActions = state->numActions + 2;
        -: 1210:				}
    #####: 1211:			}
        -: 1212:
    #####: 1213:			return 0;
        -: 1214:
        -: 1215:		case ambassador:
    #####: 1216:			j = 0;		//used to check if player has enough cards to discard
        -: 1217:
    #####: 1218:			if (choice2 > 2 || choice2 < 0)
        -: 1219:			{
    #####: 1220:				return -1;				
        -: 1221:			}
        -: 1222:
    #####: 1223:			if (choice1 == handPos)
        -: 1224:			{
    #####: 1225:				return -1;
        -: 1226:			}
        -: 1227:
    #####: 1228:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1229:			{
    #####: 1230:				if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1231:				{
    #####: 1232:					j++;
    #####: 1233:				}
    #####: 1234:			}
    #####: 1235:			if (j < choice2)
        -: 1236:			{
    #####: 1237:				return -1;				
        -: 1238:			}
        -: 1239:
        -: 1240:			if (DEBUG) 
        -: 1241:				printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1242:
        -: 1243:			//increase supply count for choosen card by amount being discarded
    #####: 1244:			state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1245:
        -: 1246:			//each other player gains a copy of revealed card
    #####: 1247:			for (i = 0; i < state->numPlayers; i++)
        -: 1248:			{
    #####: 1249:				if (i != currentPlayer)
        -: 1250:				{
    #####: 1251:					gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1252:				}
    #####: 1253:			}
        -: 1254:
        -: 1255:			//discard played card from hand
    #####: 1256:			discardCard(handPos, currentPlayer, state, 0);			
        -: 1257:
        -: 1258:			//trash copies of cards returned to supply
    #####: 1259:			for (j = 0; j < choice2; j++)
        -: 1260:			{
    #####: 1261:				for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1262:				{
    #####: 1263:					if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1264:					{
    #####: 1265:						discardCard(i, currentPlayer, state, 1);
    #####: 1266:						break;
        -: 1267:					}
    #####: 1268:				}
    #####: 1269:			}			
        -: 1270:
    #####: 1271:			return 0;
        -: 1272:
        -: 1273:		case cutpurse:
        -: 1274:
    #####: 1275:			updateCoins(currentPlayer, state, 2);
    #####: 1276:			for (i = 0; i < state->numPlayers; i++)
        -: 1277:			{
    #####: 1278:				if (i != currentPlayer)
        -: 1279:				{
    #####: 1280:					for (j = 0; j < state->handCount[i]; j++)
        -: 1281:					{
    #####: 1282:						if (state->hand[i][j] == copper)
        -: 1283:						{
    #####: 1284:							discardCard(j, i, state, 0);
    #####: 1285:							break;
        -: 1286:						}
    #####: 1287:						if (j == state->handCount[i])
        -: 1288:						{
    #####: 1289:							for (k = 0; k < state->handCount[i]; k++)
        -: 1290:							{
        -: 1291:								if (DEBUG)
        -: 1292:									printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1293:							}	
    #####: 1294:							break;
        -: 1295:						}		
    #####: 1296:					}
        -: 1297:
    #####: 1298:				}
        -: 1299:
    #####: 1300:			}				
        -: 1301:
        -: 1302:			//discard played card from hand
    #####: 1303:			discardCard(handPos, currentPlayer, state, 0);			
        -: 1304:
    #####: 1305:			return 0;
        -: 1306:
        -: 1307:
        -: 1308:		case embargo: 
        -: 1309:			//+2 Coins
    #####: 1310:			state->coins = state->coins + 2;
        -: 1311:
        -: 1312:			//see if selected pile is in play
    #####: 1313:			if ( state->supplyCount[choice1] == -1 )
        -: 1314:			{
    #####: 1315:				return -1;
        -: 1316:			}
        -: 1317:
        -: 1318:			//add embargo token to selected supply pile
    #####: 1319:			state->embargoTokens[choice1]++;
        -: 1320:
        -: 1321:			//trash card
    #####: 1322:			discardCard(handPos, currentPlayer, state, 1);		
    #####: 1323:			return 0;
        -: 1324:
        -: 1325:		case outpost:
        -: 1326:			//set outpost flag
    #####: 1327:			state->outpostPlayed++;
        -: 1328:
        -: 1329:			//discard card
    #####: 1330:			discardCard(handPos, currentPlayer, state, 0);
    #####: 1331:			return 0;
        -: 1332:
        -: 1333:		case salvager:
        -: 1334:			//+1 buy
    #####: 1335:			state->numBuys++;
        -: 1336:
    #####: 1337:			if (choice1)
        -: 1338:			{
        -: 1339:				//gain coins equal to trashed card
    #####: 1340:				state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1341:				//trash card
    #####: 1342:				discardCard(choice1, currentPlayer, state, 1);	
    #####: 1343:			}
        -: 1344:
        -: 1345:			//discard card
    #####: 1346:			discardCard(handPos, currentPlayer, state, 0);
    #####: 1347:			return 0;
        -: 1348:
        -: 1349:		case sea_hag:
    #####: 1350:			for (i = 0; i < state->numPlayers; i++){
    #####: 1351:				if (i != currentPlayer){
    #####: 1352:					state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1353:					state->discardCount[i]++;
    #####: 1354:					state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1355:				}
    #####: 1356:			}
    #####: 1357:			return 0;
        -: 1358:
        -: 1359:		case treasure_map:
        -: 1360:			//search hand for another treasure_map
    #####: 1361:			index = -1;
    #####: 1362:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1363:			{
    #####: 1364:				if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1365:				{
    #####: 1366:					index = i;
    #####: 1367:					break;
        -: 1368:				}
    #####: 1369:			}
    #####: 1370:			if (index > -1)
        -: 1371:			{
        -: 1372:				//trash both treasure cards
    #####: 1373:				discardCard(handPos, currentPlayer, state, 1);
    #####: 1374:				discardCard(index, currentPlayer, state, 1);
        -: 1375:
        -: 1376:				//gain 4 Gold cards
    #####: 1377:				for (i = 0; i < 4; i++)
        -: 1378:				{
    #####: 1379:					gainCard(gold, state, 1, currentPlayer);
    #####: 1380:				}
        -: 1381:
        -: 1382:				//return success
    #####: 1383:				return 1;
        -: 1384:			}
        -: 1385:
        -: 1386:			//no second treasure_map found in hand
    #####: 1387:			return -1;
        -: 1388:	}
        -: 1389:
    #####: 1390:	return -1;
     1560: 1391:}
        -: 1392:
        -: 1393:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1394:{
        -: 1395:
        -: 1396:	//if card is not trashed, added to Played pile 
     2629: 1397:	if (trashFlag < 1)
        -: 1398:	{
        -: 1399:		//add card to played pile
     2629: 1400:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
     2629: 1401:		state->playedCardCount++;
     2629: 1402:	}
        -: 1403:
        -: 1404:	//set played card to -1
     2629: 1405:	state->hand[currentPlayer][handPos] = -1;
        -: 1406:
        -: 1407:	//remove card from player's hand
     2629: 1408:	if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1409:	{
        -: 1410:		//reduce number of cards in hand
        2: 1411:		state->handCount[currentPlayer]--;
        2: 1412:	}
     2627: 1413:	else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1414:	{
        -: 1415:		//reduce number of cards in hand
    #####: 1416:		state->handCount[currentPlayer]--;
    #####: 1417:	}
        -: 1418:	else 	
        -: 1419:	{
        -: 1420:		//replace discarded card with last card in hand
     2627: 1421:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1422:		//set last card to -1
     2627: 1423:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1424:		//reduce number of cards in hand
     2627: 1425:		state->handCount[currentPlayer]--;
        -: 1426:	}
        -: 1427:
     2629: 1428:	return 0;
        -: 1429:}
        -: 1430:
        -: 1431:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1432:{
        -: 1433:	//Note: supplyPos is enum of choosen card
        -: 1434:
        -: 1435:	//check if supply pile is empty (0) or card is not used in game (-1)
      345: 1436:	if ( supplyCount(supplyPos, state) < 1 )
        -: 1437:	{
    #####: 1438:		return -1;
        -: 1439:	}
        -: 1440:
        -: 1441:	//added card for [whoseTurn] current player:
        -: 1442:	// toFlag = 0 : add to discard
        -: 1443:	// toFlag = 1 : add to deck
        -: 1444:	// toFlag = 2 : add to hand
        -: 1445:
      345: 1446:	if (toFlag == 1)
        -: 1447:	{
    #####: 1448:		state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1449:		state->deckCount[player]++;
    #####: 1450:	}
      345: 1451:	else if (toFlag == 2)
        -: 1452:	{
      285: 1453:		state->hand[ player ][ state->handCount[player] ] = supplyPos;
      285: 1454:		state->handCount[player]++;
      285: 1455:	}
        -: 1456:	else
        -: 1457:	{
       60: 1458:		state->discard[player][ state->discardCount[player] ] = supplyPos;
       60: 1459:		state->discardCount[player]++;
        -: 1460:	}
        -: 1461:
        -: 1462:	//decrease number in supply pile
      345: 1463:	state->supplyCount[supplyPos]--;
        -: 1464:
      345: 1465:	return 0;
      345: 1466:}
        -: 1467:
        -: 1468:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1469:{
        -: 1470:	int i;
        -: 1471:
        -: 1472:	//reset coin count
      868: 1473:	state->coins = 0;
        -: 1474:
        -: 1475:	//add coins for each Treasure card in player's hand
    68872: 1476:	for (i = 0; i < state->handCount[player]; i++)
        -: 1477:	{
    33568: 1478:		if (state->hand[player][i] == copper)
        -: 1479:		{
     3290: 1480:			state->coins += 1;
     3290: 1481:		}
    30278: 1482:		else if (state->hand[player][i] == silver)
        -: 1483:		{
      640: 1484:			state->coins += 2;
      640: 1485:		}
    29638: 1486:		else if (state->hand[player][i] == gold)
        -: 1487:		{
      693: 1488:			state->coins += 3;
      693: 1489:		}	
    33568: 1490:	}	
        -: 1491:
        -: 1492:	//add bonus
      868: 1493:	state->coins += bonus;
        -: 1494:
      868: 1495:	return 0;
        -: 1496:}
        -: 1497:
        -: 1498:
        -: 1499://end of dominion.c
        -: 1500:
